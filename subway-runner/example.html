<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>åœ°é“è·‘é…·</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #87ceeb, #98fb98);
            font-family: "Comic Sans MS", cursive, sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffd700;
            font-size: 28px;
            font-weight: bold;
            z-index: 100;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 15px;
            border: 3px solid #ffd700;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 100;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            padding: 30px;
            border-radius: 20px;
            border: 5px solid #ffd700;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 100;
            background: linear-gradient(135deg, #ff4757, #ff6b6b);
            padding: 40px;
            border-radius: 20px;
            border: 5px solid #ffd700;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            display: none;
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>ğŸ’° é‡‘å¸: <span id="score">0</span></div>
            <div>ğŸš„ é€Ÿåº¦: <span id="speed">1</span></div>
        </div>

        <div id="instructions">
            <h2>ğŸš‡ åœ°é“è·‘é…· ğŸƒâ€â™‚ï¸</h2>
            <p>ğŸ® A/D æˆ– â†/â†’ : å·¦å³ç§»åŠ¨</p>
            <p>ğŸ¦˜ W æˆ– â†‘ : è·³è·ƒ</p>
            <button onclick="startGame()">ğŸš€ å¼€å§‹å†’é™©</button>
        </div>

        <div id="gameOver">
            <h2>ğŸ’¥ æ¸¸æˆç»“æŸ ğŸ’¥</h2>
            <p>ğŸ† æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        
        class SubwaySurfersGame {
            constructor() {
                //  æ¸¸æˆå¸¸é‡é…ç½®
                // è½¨é“å®½åº¦ - æ§åˆ¶ç©å®¶å·¦å³ç§»åŠ¨çš„é—´éš”
                this.LANE_WIDTH = 5.5;
                // åœ°é¢é•¿åº¦ - æ§åˆ¶åœºæ™¯çš„çºµå‘å»¶ä¼¸è·ç¦»
                this.GROUND_LENGTH = 200;
                // åŸºç¡€ç©å®¶ç§»åŠ¨é€Ÿåº¦ - æ§åˆ¶æ¸¸æˆæ•´ä½“èŠ‚å¥
                this.PLAYER_SPEED = 0.3;
                // è·³è·ƒåŠ›åº¦ - æ§åˆ¶ç©å®¶è·³è·ƒé«˜åº¦
                this.JUMP_FORCE = 0.6;
                // é‡åŠ›åŠ é€Ÿåº¦ - æ§åˆ¶ç©å®¶ä¸‹è½é€Ÿåº¦
                this.GRAVITY = 0.025;
                // ç›®æ ‡ç©å®¶é«˜åº¦ - ç”¨äºæ¨¡å‹ç¼©æ”¾
                this.TARGET_PLAYER_HEIGHT = 1.2;
                
                // æ¸¸æˆçŠ¶æ€å˜é‡ 
                this.gameStarted = false;   // æ¸¸æˆæ˜¯å¦å·²å¼€å§‹
                this.gameRunning = false;   // æ¸¸æˆæ˜¯å¦æ­£åœ¨è¿è¡Œ
                this.score = 0;             // å½“å‰å¾—åˆ†
                this.speed = 1;             // å½“å‰æ¸¸æˆé€Ÿåº¦å€æ•°
                this.playerLane = 0;        // ç©å®¶å½“å‰æ‰€åœ¨è½¨é“(-1å·¦,0ä¸­,1å³)
                this.isJumping = false;     // ç©å®¶æ˜¯å¦å¤„äºè·³è·ƒçŠ¶æ€
                this.isSliding = false;    // ç©å®¶æ˜¯å¦å¤„äºæ»‘è¡ŒçŠ¶æ€(æœªå®ç°)
                this.jumpVelocity = 0;      // å½“å‰è·³è·ƒé€Ÿåº¦
                
                // Three.jsç›¸å…³å˜é‡ 
                this.clock = new THREE.Clock(); // Three.jsæ—¶é’Ÿï¼Œç”¨äºç²¾ç¡®è®¡æ—¶
                this.mixer = null;         // åŠ¨ç”»æ··åˆå™¨ï¼Œç”¨äºå¤„ç†è§’è‰²åŠ¨ç”»
                this.playerActions = {};    // å­˜å‚¨ä¸åŒåŠ¨ç”»åŠ¨ä½œ(å¦‚è·‘ã€è·³ç­‰)
                
                // æ¸¸æˆå¯¹è±¡ 
                this.scene = null;          // Three.jsåœºæ™¯
                this.camera = null;         // ç›¸æœº
                this.renderer = null;       // æ¸²æŸ“å™¨
                this.player = null;         // ç©å®¶è§’è‰²æ¨¡å‹(ä»GLTFåŠ è½½)
                this.playerModelRoot = null;// ç©å®¶æ¨¡å‹çš„æ ¹å¯¹è±¡(ç”¨äºä½ç½®è°ƒæ•´)
                this.ground = null;        // åœ°é¢å¯¹è±¡
                this.coins = [];           // é‡‘å¸æ•°ç»„
                this.buildings = [];       // å»ºç­‘ç‰©æ•°ç»„
                this.trains = [];          // ç«è½¦æ•°ç»„
                
                // èµ„æºåŠ è½½å™¨ ===============
                this.loader = new GLTFLoader();     // GLTFæ¨¡å‹åŠ è½½å™¨
                this.textureLoader = new THREE.TextureLoader(); // çº¹ç†åŠ è½½å™¨
                
                // =============== é¢œè‰²é…ç½® ===============
                this.COLORS = {
                    player: 0xff6b6b,       // ç©å®¶é¢œè‰²
                    ground: 0x8b4513,      // åœ°é¢é¢œè‰²
                    tracks: 0x333333,      // è½¨é“é¢œè‰²
                    train: 0x2ecc71,       // ç«è½¦é¢œè‰²
                    buildings: [0xff9ff3, 0x54a0ff, 0x5f27cd, 0x00d2d3, 0xff9f43], // å»ºç­‘ç‰©é¢œè‰²æ•°ç»„
                    coins: 0xffd700,       // é‡‘å¸é¢œè‰²
                };
                
                // =============== èµ„æºé¢„åŠ è½½ ===============
                this.resources = {
                    playerModel: null,      // ç©å®¶æ¨¡å‹
                    buildingModels: [],     // å»ºç­‘ç‰©æ¨¡å‹æ•°ç»„
                    trainModel: null,       // ç«è½¦æ¨¡å‹
                    groundTexture: null     // åœ°é¢çº¹ç†
                };
                
                // åˆå§‹åŒ–æ¸¸æˆ
                this.initGame();
            }
            
            /**
             * åˆå§‹åŒ–æ¸¸æˆ - åŠ è½½èµ„æºå¹¶è®¾ç½®æ¸¸æˆ
             * ä½¿ç”¨å¼‚æ­¥åŠ è½½ç¡®ä¿æ‰€æœ‰èµ„æºåŠ è½½å®Œæˆåå†åˆå§‹åŒ–åœºæ™¯
             */
            async initGame() {
                try {
                    // ä½¿ç”¨Promise.allå¹¶è¡ŒåŠ è½½æ‰€æœ‰èµ„æº
                    await Promise.all([
                        this.loadPlayerModel(),     // åŠ è½½ç©å®¶æ¨¡å‹
                        this.loadBuildingModels(), // åŠ è½½å»ºç­‘ç‰©æ¨¡å‹
                        this.loadTrainModel(),     // åŠ è½½ç«è½¦æ¨¡å‹
                        this.loadGroundTexture()  // åŠ è½½åœ°é¢çº¹ç†
                    ]);
                    
                    // èµ„æºåŠ è½½å®Œæˆååˆå§‹åŒ–åœºæ™¯
                    this.initScene();
                    
                    // æ˜¾ç¤ºå¼€å§‹ç•Œé¢
                    document.getElementById("instructions").style.display = "block";
                    document.getElementById("gameOver").style.display = "none";
                } catch (error) {
                    console.error("æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:", error);
                }
            }
            
            /**
             * åŠ è½½ç©å®¶æ¨¡å‹
             * ä½¿ç”¨GLTFLoaderåŠ è½½GLBæ ¼å¼çš„3Dæ¨¡å‹
             * @return {Promise} åŠ è½½å®Œæˆçš„Promise
             */
            loadPlayerModel() {
                return new Promise((resolve, reject) => {
                    // ä½¿ç”¨GLTFLoaderåŠ è½½æ¨¡å‹
                    this.loader.load(
                        "./assets/models/player1.glb", // æ¨¡å‹è·¯å¾„
                        (gltf) => {
                            // è®¡ç®—æ¨¡å‹åŒ…å›´ç›’ä»¥ç¡®å®šåŸå§‹å°ºå¯¸
                            const bbox = new THREE.Box3().setFromObject(gltf.scene);
                            const originalHeight = bbox.max.y - bbox.min.y;
                            
                            // è®¡ç®—ç¼©æ”¾å› å­ä½¿æ¨¡å‹é«˜åº¦æ ‡å‡†åŒ–
                            gltf.scene.userData.scaleFactor = this.TARGET_PLAYER_HEIGHT / originalHeight;
                            
                            // å­˜å‚¨åŠ è½½çš„æ¨¡å‹
                            this.resources.playerModel = gltf.scene;

                            // åˆå§‹åŒ–åŠ¨ç”»æ··åˆå™¨
                            this.mixer = new THREE.AnimationMixer(gltf.scene);
                            
                            // å¤„ç†æ¨¡å‹ä¸­çš„åŠ¨ç”»ç‰‡æ®µ
                            gltf.animations.forEach((clip) => {
                                // å‡è®¾ç¬¬ä¸€ä¸ªåŠ¨ç”»æ˜¯è·‘æ­¥åŠ¨ç”»
                                if (this.playerActions.run === undefined) {
                                     this.playerActions.run = this.mixer.clipAction(clip);
                                }
                            });

                            resolve(); // åŠ è½½å®Œæˆ
                        },
                        undefined, // è¿›åº¦å›è°ƒ(æœªä½¿ç”¨)
                        (error) => {
                            console.error("åŠ è½½ç©å®¶æ¨¡å‹å¤±è´¥:", error);
                            reject(error); // åŠ è½½å¤±è´¥
                        }
                    );
                });
            }
            
            /**
             * åŠ è½½å»ºç­‘ç‰©æ¨¡å‹
             * åŠ è½½å¤šä¸ªå»ºç­‘ç‰©æ¨¡å‹ç”¨äºåœºæ™¯è£…é¥°
             * @return {Promise} æ‰€æœ‰å»ºç­‘ç‰©åŠ è½½å®Œæˆçš„Promise
             */
            loadBuildingModels() {
                // å»ºç­‘ç‰©æ¨¡å‹è·¯å¾„æ•°ç»„
                const paths = [
                    "./assets/models/house1.glb",
                    "./assets/models/house3.glb",
                ];
                
                // ä½¿ç”¨Promise.allå¹¶è¡ŒåŠ è½½æ‰€æœ‰å»ºç­‘ç‰©æ¨¡å‹
                return Promise.all(paths.map((path, index) => {
                    return new Promise((resolve, reject) => {
                        this.loader.load(
                            path,
                            (gltf) => {
                                // å­˜å‚¨åŠ è½½çš„å»ºç­‘ç‰©æ¨¡å‹
                                this.resources.buildingModels[index] = gltf.scene;
                                resolve();
                            },
                            undefined,
                            (error) => {
                                console.error(`åŠ è½½å»ºç­‘æ¨¡å‹ ${path} å¤±è´¥:`, error);
                                reject(error);
                            }
                        );
                    });
                }));
            }
            
            /**
             * åŠ è½½ç«è½¦æ¨¡å‹
             * @return {Promise} ç«è½¦æ¨¡å‹åŠ è½½å®Œæˆçš„Promise
             */
            loadTrainModel() {
                return new Promise((resolve, reject) => {
                    this.loader.load(
                        "./assets/models/train.glb",
                        (gltf) => {
                            // å­˜å‚¨åŠ è½½çš„ç«è½¦æ¨¡å‹
                            this.resources.trainModel = gltf.scene;
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.error("åŠ è½½ç«è½¦æ¨¡å‹å¤±è´¥:", error);
                            reject(error);
                        }
                    );
                });
            }
            
            /**
             * åŠ è½½åœ°é¢çº¹ç†
             * åŠ è½½å¹¶é…ç½®åœ°é¢é‡å¤çº¹ç†
             * @return {Promise} çº¹ç†åŠ è½½å®Œæˆçš„Promise
             */
            loadGroundTexture() {
                return new Promise((resolve, reject) => {
                    this.textureLoader.load(
                        "./assets/textures/track1.png",
                        (texture) => {
                            // é…ç½®çº¹ç†é‡å¤æ¨¡å¼
                            this.resources.groundTexture = texture;
                            texture.wrapS = THREE.RepeatWrapping; // æ°´å¹³é‡å¤
                            texture.wrapT = THREE.RepeatWrapping; // å‚ç›´é‡å¤
                            texture.repeat.set(1, 10); // è®¾ç½®é‡å¤æ¬¡æ•°(æ²¿Zè½´é‡å¤10æ¬¡)
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.error("åŠ è½½åœ°é¢çº¹ç†å¤±è´¥:", error);
                            reject(error);
                        }
                    );
                });
            }
            
            /**
             * åˆå§‹åŒ–æ¸¸æˆåœºæ™¯
             * åˆ›å»ºThree.jsåœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨åŠæ‰€æœ‰æ¸¸æˆå¯¹è±¡
             */
            initScene() {
                // =============== åˆ›å»ºThree.jsåœºæ™¯ ===============
                this.scene = new THREE.Scene();
                // æ·»åŠ é›¾æ•ˆå¢å¼ºæ·±åº¦æ„Ÿ
                this.scene.fog = new THREE.Fog(0x87ceeb, 30, 150);
                
                // =============== åˆ›å»ºç›¸æœº ===============
                this.camera = new THREE.PerspectiveCamera(
                    75, // è§†é‡è§’åº¦
                    window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                    0.1, // è¿‘è£å‰ªé¢
                    1000 // è¿œè£å‰ªé¢
                );
                // è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®å’Œæœå‘
                this.camera.position.set(0, 5, 15);
                this.camera.lookAt(0, 1, -10);
                
                // =============== åˆ›å»ºæ¸²æŸ“å™¨ ===============
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true // å¼€å¯æŠ—é”¯é½¿
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87ceeb); // è®¾ç½®èƒŒæ™¯è‰²
                this.renderer.shadowMap.enabled = true; // å¯ç”¨é˜´å½±
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ä½¿ç”¨è½¯é˜´å½±
                // å°†æ¸²æŸ“å™¨çš„DOMå…ƒç´ æ·»åŠ åˆ°é¡µé¢
                document.getElementById("gameContainer").appendChild(this.renderer.domElement);
                
                // =============== åˆ›å»ºå…‰æº ===============
                // å¹³è¡Œå…‰(ä¸»å…‰æº)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 2.2);
                directionalLight.position.set(15, 25, 10);
                directionalLight.castShadow = true; // æŠ•å°„é˜´å½±
                // è®¾ç½®é˜´å½±è´´å›¾åˆ†è¾¨ç‡
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // ç¯å¢ƒå…‰(è¡¥å……å…‰æº)
                const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
                this.scene.add(ambientLight);

                // =============== åˆ›å»ºæ¸¸æˆå…ƒç´  ===============
                this.createGround();    // åˆ›å»ºåœ°é¢
                this.createTrains();    // åˆ›å»ºç«è½¦
                this.createBuildings(); // åˆ›å»ºå»ºç­‘ç‰©
                this.createPlayer();    // åˆ›å»ºç©å®¶è§’è‰²
                this.generateCoins();   // ç”Ÿæˆé‡‘å¸
                
                // è®¾ç½®æ¸¸æˆæ§åˆ¶
                this.setupControls();
                
                // å¼€å§‹åŠ¨ç”»å¾ªç¯
                this.animate();
                
                // ç›‘å¬çª—å£å¤§å°å˜åŒ–äº‹ä»¶
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            /**
             * çª—å£å¤§å°è°ƒæ•´å¤„ç†
             * å“åº”å¼è°ƒæ•´ç›¸æœºå’Œæ¸²æŸ“å™¨
             */
            onWindowResize() {
                // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix(); // å¿…é¡»è°ƒç”¨æ­¤æ–¹æ³•ä½¿æ›´æ”¹ç”Ÿæ•ˆ
                // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            /**
             * åˆ›å»ºåœ°é¢
             * ä½¿ç”¨å¹³é¢å‡ ä½•ä½“åˆ›å»ºå¸¦æœ‰çº¹ç†çš„åœ°é¢
             */
            createGround() {
                // åˆ›å»ºåœ°é¢å‡ ä½•ä½“(å®½åº¦20ï¼Œé•¿åº¦GROUND_LENGTH)
                const groundGeometry = new THREE.PlaneGeometry(20, this.GROUND_LENGTH);
                // åˆ›å»ºåœ°é¢æè´¨(ä½¿ç”¨åŠ è½½çš„çº¹ç†)
                const groundMaterial = new THREE.MeshLambertMaterial({
                    map: this.resources.groundTexture, // è®¾ç½®çº¹ç†
                    transparent: true,    // å¯ç”¨é€æ˜åº¦
                    opacity: 0.95,       // è®¾ç½®ä¸é€æ˜åº¦
                });
                
                // åˆ›å»ºåœ°é¢ç½‘æ ¼å¯¹è±¡
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                // æ—‹è½¬åœ°é¢ä½¿å…¶æ°´å¹³
                this.ground.rotation.x = -Math.PI / 2;
                // è®¾ç½®åœ°é¢ä½ç½®(ç¨å¾®ä½äºç©å®¶)
                this.ground.position.y = -1;
                // å…è®¸åœ°é¢æ¥æ”¶é˜´å½±
                this.ground.receiveShadow = true;
                // å°†åœ°é¢æ·»åŠ åˆ°åœºæ™¯
                this.scene.add(this.ground);
            }
            
            /**
             * åˆ›å»ºç«è½¦
             * åœ¨è½¨é“ä¸Šç”Ÿæˆå¤šåˆ—ç«è½¦
             */
            createTrains() {
                const trainCount = 6;       // ç«è½¦æ•°é‡
                const minSpacing = 55;      // ç«è½¦é—´æœ€å°é—´è·
                const maxSpacing = 80;       // ç«è½¦é—´æœ€å¤§é—´è·
                // ç«è½¦è½¨é“åˆ†å¸ƒæ¨¡å¼(é˜²æ­¢æ‰€æœ‰ç«è½¦åœ¨åŒä¸€è½¨é“)
                const lanePatterns = [
                    [-1, 0, 1, -1, 0, 1],  // æ¨¡å¼1: å·¦ä¸­å³å·¦ä¸­å³
                    [0, 1, -1, 0, 1, -1],   // æ¨¡å¼2: ä¸­å³å·¦ä¸­å³å·¦
                    [0, 0, 1, -1, 0, 1]     // æ¨¡å¼3: ä¸­ä¸­å³å·¦ä¸­å³
                ];
                // éšæœºé€‰æ‹©ä¸€ä¸ªåˆ†å¸ƒæ¨¡å¼
                const pattern = lanePatterns[Math.floor(Math.random() * lanePatterns.length)];
                
                let currentZ = 10; // åˆå§‹Zä½ç½®
                
                // åˆ›å»ºæ‰€æœ‰ç«è½¦
                for (let i = 0; i < trainCount; i++) {
                    const lane = pattern[i % pattern.length]; // æ ¹æ®æ¨¡å¼é€‰æ‹©è½¨é“
                    // éšæœºé—´è·(å¢åŠ å˜åŒ–æ€§)
                    const spacing = minSpacing + Math.random() * (maxSpacing - minSpacing);
                    
                    // å…‹éš†ç«è½¦æ¨¡å‹(é¿å…é‡å¤åŠ è½½)
                    const train = this.resources.trainModel.clone();
                    // è®¾ç½®ç«è½¦ä½ç½®(æ ¹æ®è½¨é“å’Œé—´è·)
                    train.position.set(lane * this.LANE_WIDTH, 0, currentZ);
                    // ç¼©æ”¾ç«è½¦æ¨¡å‹
                    train.scale.set(0.15, 0.15, 0.15);
                    // æ—‹è½¬ç«è½¦ä½¿å…¶æœå‘æ­£ç¡®æ–¹å‘
                    train.rotation.y = Math.PI;
                    
                    // éå†ç«è½¦æ‰€æœ‰å­å¯¹è±¡è®¾ç½®é˜´å½±
                    train.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;    // æŠ•å°„é˜´å½±
                            child.receiveShadow = true; // æ¥æ”¶é˜´å½±
                        }
                    });
                    
                    // å­˜å‚¨ç«è½¦è‡ªå®šä¹‰æ•°æ®
                    train.userData = {
                        lane: lane, // æ‰€åœ¨è½¨é“
                        speed: 0.8 + Math.random() * 0.4 // éšæœºé€Ÿåº¦
                    };
                    
                    // æ·»åŠ åˆ°ç«è½¦æ•°ç»„å’Œåœºæ™¯
                    this.trains.push(train);
                    this.scene.add(train);
                    
                    // æ›´æ–°ä¸‹ä¸€ä¸ªç«è½¦çš„ä½ç½®
                    currentZ -= spacing;
                }
            }
            
            /**
             * åˆ›å»ºå»ºç­‘ç‰©
             * åœ¨è½¨é“ä¸¤ä¾§ç”Ÿæˆå»ºç­‘ç‰©ä½œä¸ºåœºæ™¯è£…é¥°
             */
            createBuildings() {
                const spacing = 10; // å»ºç­‘ç‰©é—´è·
                // æ¯ä¾§å»ºç­‘ç‰©æ•°é‡(æ ¹æ®åœ°é¢é•¿åº¦è®¡ç®—)
                const countPerSide = Math.floor(this.GROUND_LENGTH / spacing);
                const leftX = -12;  // å·¦ä¾§å»ºç­‘ç‰©Xåæ ‡
                const rightX = 22;  // å³ä¾§å»ºç­‘ç‰©Xåæ ‡
                
                // å»ºç­‘ç‰©é…ç½®(ç¼©æ”¾å’Œæ—‹è½¬)
                const buildingConfigs = [
                    { scale: [2.2, 2.2, 2.2], rotationY: Math.PI / 2 }, // å·¦ä¾§å»ºç­‘ç‰©é…ç½®
                    { scale: [1.2, 1.2, 1.2], rotationY: -Math.PI / 2 }, // å³ä¾§å»ºç­‘ç‰©é…ç½®
                ];
                
                // åˆ›å»ºå»ºç­‘ç‰©
                for (let i = 0; i < countPerSide; i++) {
                    // è®¡ç®—å»ºç­‘ç‰©Zä½ç½®(ä»åœºæ™¯åç«¯å¼€å§‹)
                    const zPos = -this.GROUND_LENGTH / 2 + i * spacing;
                    
                    // =============== åˆ›å»ºå·¦ä¾§å»ºç­‘ç‰© ===============
                    const leftModel = this.resources.buildingModels[0].clone();
                    const leftConfig = buildingConfigs[0];
                    leftModel.position.set(leftX, -1, zPos);
                    leftModel.scale.set(...leftConfig.scale);
                    leftModel.rotation.y = leftConfig.rotationY;
                    // è®¾ç½®é˜´å½±
                    leftModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    this.scene.add(leftModel);
                    this.buildings.push(leftModel);
                    
                    // =============== åˆ›å»ºå³ä¾§å»ºç­‘ç‰© ===============
                    const rightModel = this.resources.buildingModels[1].clone();
                    const rightConfig = buildingConfigs[1];
                    rightModel.position.set(rightX, -1, zPos);
                    rightModel.scale.set(...rightConfig.scale);
                    rightModel.rotation.y = rightConfig.rotationY;
                    // è®¾ç½®é˜´å½±
                    rightModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    this.scene.add(rightModel);
                    this.buildings.push(rightModel);
                }
            }
            
            /**
             * åˆ›å»ºç©å®¶è§’è‰²
             * åˆå§‹åŒ–ç©å®¶æ¨¡å‹å¹¶è®¾ç½®åŠ¨ç”»
             */
            createPlayer() {
                // æ£€æŸ¥æ¨¡å‹æ˜¯å¦å·²åŠ è½½
                if (!this.resources.playerModel) {
                    console.warn("ç©å®¶æ¨¡å‹è¿˜æ²¡åŠ è½½å®Œ");
                    return;
                }
                
                // ä½¿ç”¨åŠ è½½çš„ç©å®¶æ¨¡å‹
                this.player = this.resources.playerModel;
                // åº”ç”¨ä¹‹å‰è®¡ç®—çš„ç¼©æ”¾å› å­
                const scale = this.resources.playerModel.userData.scaleFactor;
                this.player.scale.set(scale, scale, scale);
                // åˆå§‹ä½ç½®
                this.player.position.set(0, 0, 0);
                // æ—‹è½¬ç©å®¶ä½¿å…¶é¢å‘æ­£ç¡®æ–¹å‘
                this.player.rotation.y = Math.PI;

                // éå†ç©å®¶æ¨¡å‹æ‰€æœ‰å­å¯¹è±¡
                this.player.traverse((child) => {
                    if (child.isMesh) {
                        // è®¾ç½®é˜´å½±
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // è°ƒæ•´æè´¨å±æ€§æé«˜å¯è§æ€§
                        if (child.material) {
                            child.material.transparent = false;
                            child.material.opacity = 1;
                            child.material.color.set(0xffffff); // è®¾ç½®åŸºç¡€é¢œè‰²
                            if (child.material.emissive) {
                                child.material.emissive.set(0x222222); // è®¾ç½®è‡ªå‘å…‰
                            }
                            child.material.needsUpdate = true; // æ ‡è®°æè´¨éœ€è¦æ›´æ–°
                        }
                    }
                });
                
                // å°†ç©å®¶æ·»åŠ åˆ°åœºæ™¯
                this.scene.add(this.player);
            }
            
            /**
             * ç”Ÿæˆé‡‘å¸
             * åœ¨è½¨é“ä¸Šç”Ÿæˆå¯æ”¶é›†çš„é‡‘å¸
             */
            generateCoins() {
                const coinCount = 80; // é‡‘å¸æ€»æ•°
                // é‡‘å¸åˆ†å¸ƒæ¨¡å¼(é¿å…æ‰€æœ‰é‡‘å¸åœ¨åŒä¸€è½¨é“)
                const coinPatterns = [
                    [0, 1, -1, 0, 1, -1], // æ¨¡å¼1: ä¸­å³å·¦ä¸­å³å·¦
                    [-1, 0, 1, -1, 0, 1], // æ¨¡å¼2: å·¦ä¸­å³å·¦ä¸­å³
                    [0, 0, 1, -1, 0, 0]   // æ¨¡å¼3: ä¸­ä¸­å³å·¦ä¸­ä¸­
                ];
                // éšæœºé€‰æ‹©ä¸€ä¸ªåˆ†å¸ƒæ¨¡å¼
                const pattern = coinPatterns[Math.floor(Math.random() * coinPatterns.length)];
                
                // åˆ›å»ºæ‰€æœ‰é‡‘å¸
                for (let i = 0; i < coinCount; i++) {
                    // æ ¹æ®æ¨¡å¼é€‰æ‹©è½¨é“
                    const lane = pattern[i % pattern.length];
                    // åˆ›å»ºå•ä¸ªé‡‘å¸
                    const coinGroup = this.createSingleCoin(lane, i);
                    // æ·»åŠ åˆ°é‡‘å¸æ•°ç»„å’Œåœºæ™¯
                    this.coins.push(coinGroup);
                    this.scene.add(coinGroup);
                }
            }
            
            /**
             * åˆ›å»ºå•ä¸ªé‡‘å¸
             * @param {number} lane - é‡‘å¸æ‰€åœ¨è½¨é“(-1å·¦,0ä¸­,1å³)
             * @param {number} index - é‡‘å¸ç´¢å¼•(ç”¨äºZä½ç½®è®¡ç®—)
             * @return {THREE.Group} é‡‘å¸ç»„å¯¹è±¡
             */
            createSingleCoin(lane, index) {
                // ä½¿ç”¨Groupç»„åˆå¤šä¸ªå‡ ä½•ä½“æ„æˆé‡‘å¸
                const coinGroup = new THREE.Group();
                
                // =============== é‡‘å¸ä¸»ä½“ ===============
                // ä½¿ç”¨åœ†æŸ±ä½“å‡ ä½•ä½“
                const coinGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.2, 24);
                // ä½¿ç”¨Phongæè´¨å®ç°é‡‘å±åå…‰æ•ˆæœ
                const coinMaterial = new THREE.MeshPhongMaterial({
                    color: this.COLORS.coins, // é‡‘å¸é¢œè‰²
                    shininess: 100,          // é«˜å…‰å¼ºåº¦
                    specular: 0xffffff        // é«˜å…‰é¢œè‰²
                });
                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                
                // =============== é‡‘å¸å†…ç¯ ===============
                // ä½¿ç”¨åœ†ç¯å‡ ä½•ä½“å¢åŠ ç»†èŠ‚
                const innerRing = new THREE.Mesh(
                    new THREE.RingGeometry(0.3, 0.5, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffffff }) // ç™½è‰²å†…ç¯
                );
                innerRing.rotation.x = Math.PI / 2; // æ—‹è½¬ä½¿å…¶æ°´å¹³
                
                // å°†éƒ¨ä»¶æ·»åŠ åˆ°é‡‘å¸ç»„
                coinGroup.add(coin);
                coinGroup.add(innerRing);
                // è®¾ç½®é‡‘å¸ä½ç½®(æ ¹æ®è½¨é“å’Œç´¢å¼•)
                coinGroup.position.set(lane * this.LANE_WIDTH, 2, -20 - index * 5);
                // æ—‹è½¬é‡‘å¸ä½¿å…¶é¢å‘ç›¸æœº
                coinGroup.rotation.x = Math.PI / 2;
                // å­˜å‚¨é‡‘å¸è‡ªå®šä¹‰æ•°æ®
                coinGroup.userData = { 
                    lane: lane,   // æ‰€åœ¨è½¨é“
                    active: true  // æ˜¯å¦å¯æ”¶é›†
                };
                
                return coinGroup;
            }
            
            /**
             * è®¾ç½®æ¸¸æˆæ§åˆ¶
             * ç›‘å¬é”®ç›˜äº‹ä»¶æ§åˆ¶ç©å®¶ç§»åŠ¨
             */
            setupControls() {
                document.addEventListener("keydown", (event) => {
                    // æ¸¸æˆæœªè¿è¡Œæ—¶å¿½ç•¥è¾“å…¥
                    if (!this.gameRunning) return;
                    
                    // æ ¹æ®æŒ‰é”®æ‰§è¡Œä¸åŒåŠ¨ä½œ
                    switch (event.code) {
                        case "KeyA":
                        case "ArrowLeft":
                            this.moveLeft(); // å‘å·¦ç§»åŠ¨
                            break;
                        case "KeyD":
                        case "ArrowRight":
                            this.moveRight(); // å‘å³ç§»åŠ¨
                            break;
                        case "KeyW":
                        case "ArrowUp":
                            this.jump(); // è·³è·ƒ
                            break;
                    }
                });
            }
            
            /**
             * å‘å·¦ç§»åŠ¨
             * æ”¹å˜ç©å®¶æ‰€åœ¨è½¨é“(å®é™…ç§»åŠ¨åœ¨updateä¸­å¹³æ»‘å¤„ç†)
             */
            moveLeft() {
                // æ£€æŸ¥æ˜¯å¦åœ¨æœ€å·¦ä¾§è½¨é“
                if (this.playerLane > -1) {
                    this.playerLane--; // æ›´æ–°è½¨é“ç´¢å¼•
                }
            }
            
            /**
             * å‘å³ç§»åŠ¨
             * æ”¹å˜ç©å®¶æ‰€åœ¨è½¨é“(å®é™…ç§»åŠ¨åœ¨updateä¸­å¹³æ»‘å¤„ç†)
             */
            moveRight() {
                // æ£€æŸ¥æ˜¯å¦åœ¨æœ€å³ä¾§è½¨é“
                if (this.playerLane < 1) {
                    this.playerLane++; // æ›´æ–°è½¨é“ç´¢å¼•
                }
            }
            
            /**
             * è·³è·ƒ
             * è®¾ç½®è·³è·ƒçŠ¶æ€å’Œåˆé€Ÿåº¦
             */
            jump() {
                // æ£€æŸ¥æ˜¯å¦å·²å¤„äºè·³è·ƒçŠ¶æ€
                if (!this.isJumping) {
                    this.isJumping = true; // è®¾ç½®è·³è·ƒçŠ¶æ€
                    this.jumpVelocity = this.JUMP_FORCE; // è®¾ç½®è·³è·ƒåˆé€Ÿåº¦
                    // è¿™é‡Œå¯ä»¥æ·»åŠ è·³è·ƒåŠ¨ç”»è§¦å‘
                }
            }
            
            /**
             * æ›´æ–°ç©å®¶ä½ç½®
             * å¤„ç†ç©å®¶å·¦å³ç§»åŠ¨çš„å¹³æ»‘è¿‡æ¸¡å’Œè·³è·ƒç‰©ç†
             */
            updatePlayerPosition() {
                // è®¡ç®—ç›®æ ‡Xä½ç½®(æ ¹æ®å½“å‰è½¨é“)
                const targetX = this.playerLane * this.LANE_WIDTH;
                // ä½¿ç”¨çº¿æ€§æ’å€¼å®ç°å¹³æ»‘ç§»åŠ¨
                this.player.position.x = THREE.MathUtils.lerp(
                    this.player.position.x, // å½“å‰ä½ç½®
                    targetX,               // ç›®æ ‡ä½ç½®
                    0.15                   // æ’å€¼ç³»æ•°(0-1)
                );
            }
            
            /**
             * ç¢°æ’æ£€æµ‹
             * æ£€æŸ¥ç©å®¶æ˜¯å¦ä¸ç«è½¦ç›¸æ’
             * @return {boolean} æ˜¯å¦å‘ç”Ÿç¢°æ’
             */
            checkPlayerCollision() {
                // ç©å®¶æ¨¡å‹æœªåŠ è½½æ—¶è¿”å›æ— ç¢°æ’
                if (!this.player) return false;
                
                // è®¡ç®—ç©å®¶åŒ…å›´ç›’
                const playerBox = new THREE.Box3().setFromObject(this.player);
                
                // æ£€æŸ¥ä¸æ‰€æœ‰ç«è½¦çš„ç¢°æ’
                for (const train of this.trains) {
                    // è·³è¿‡æ— æ•ˆç«è½¦
                    if (!train || !train.userData) continue;
                    
                    // è®¡ç®—ç«è½¦åŒ…å›´ç›’
                    const trainBox = new THREE.Box3().setFromObject(train);
                    // æ£€æŸ¥åŒ…å›´ç›’æ˜¯å¦ç›¸äº¤
                    if (playerBox.intersectsBox(trainBox)) {
                        return true; // å‘ç”Ÿç¢°æ’
                    }
                }
                
                return false; // æ— ç¢°æ’
            }
            
            /**
             * æ›´æ–°æ¸¸æˆçŠ¶æ€
             * æ¯å¸§è°ƒç”¨ï¼Œå¤„ç†æ¸¸æˆé€»è¾‘
             */
            update() {
                // æ¸¸æˆæœªè¿è¡Œæˆ–ç©å®¶æœªåŠ è½½æ—¶è·³è¿‡æ›´æ–°
                if (!this.gameRunning || !this.player) return;
                
                // è·å–å¸§æ—¶é—´å·®(ç”¨äºå¹³æ»‘åŠ¨ç”»)
                const delta = this.clock.getDelta();

                // æ›´æ–°åŠ¨ç”»æ··åˆå™¨
                if (this.mixer) {
                    this.mixer.update(delta);
                }

                // =============== æ›´æ–°åˆ†æ•°å’Œé€Ÿåº¦ ===============
                // åˆ†æ•°éšé€Ÿåº¦å¢åŠ 
                this.score += Math.floor(this.speed * 0.5);
                // é€Ÿåº¦éšæ—¶é—´é€æ¸å¢åŠ 
                this.speed += 0.002 * delta * 60; // ä¹˜ä»¥60ä½¿é€Ÿåº¦å˜åŒ–ä¸å¸§ç‡æ— å…³
                // æ›´æ–°UIæ˜¾ç¤º
                document.getElementById("score").textContent = Math.floor(this.score);
                document.getElementById("speed").textContent = this.speed.toFixed(2);
                
                // =============== æ›´æ–°ç©å®¶ä½ç½® ===============
                this.updatePlayerPosition();
                
                // =============== å¤„ç†è·³è·ƒç‰©ç† ===============
                if (this.isJumping || this.player.position.y > 0) {
                    // æ›´æ–°Yä½ç½®(é€Ÿåº¦éšæ—¶é—´é€’å‡)
                    this.player.position.y += this.jumpVelocity;
                    // åº”ç”¨é‡åŠ›
                    this.jumpVelocity -= this.GRAVITY;
                }
                
                // =============== å¤„ç†è½åœ° ===============
                if (this.player.position.y <= 0) {
                    this.player.position.y = 0; // é‡ç½®é«˜åº¦
                    this.isJumping = false;     // é‡ç½®è·³è·ƒçŠ¶æ€
                    this.jumpVelocity = 0;      // é‡ç½®é€Ÿåº¦
                    // è¿™é‡Œå¯ä»¥é‡ç½®ä¸ºè·‘æ­¥åŠ¨ç”»
                }
                
                // =============== ç¢°æ’æ£€æµ‹ ===============
                if (this.checkPlayerCollision()) {
                    this.gameOver(); // æ¸¸æˆç»“æŸ
                    return;
                }
                
                // =============== æ›´æ–°æ¸¸æˆå¯¹è±¡ ===============
                this.updateTrains();    // æ›´æ–°ç«è½¦ä½ç½®
                this.updateBuildings(); // æ›´æ–°å»ºç­‘ç‰©ä½ç½®
                this.updateCoins();    // æ›´æ–°é‡‘å¸çŠ¶æ€
                
                // =============== ç›¸æœºè·Ÿéš ===============
                this.camera.position.z = this.player.position.z + 15;
            }
            
            /**
             * æ›´æ–°ç«è½¦ä½ç½®
             * å¤„ç†ç«è½¦çš„ç§»åŠ¨å’Œå¾ªç¯
             */
            updateTrains() {
                for (const train of this.trains) {
                    // è·³è¿‡æ— æ•ˆç«è½¦
                    if (!train || !train.userData) continue;
                    
                    // æ ¹æ®æ¸¸æˆé€Ÿåº¦ç§»åŠ¨ç«è½¦
                    train.position.z += this.PLAYER_SPEED * this.speed * train.userData.speed;
                    
                    // æ£€æŸ¥ç«è½¦æ˜¯å¦è¶…å‡ºè§†é‡
                    if (train.position.z > 80) {
                        // éšæœºé€‰æ‹©æ–°è½¨é“
                        const randomLane = Math.floor(Math.random() * 3) - 1;
                        // é‡ç½®ç«è½¦ä½ç½®åˆ°åœºæ™¯åæ–¹
                        train.position.x = randomLane * this.LANE_WIDTH;
                        train.position.z = -80 - Math.random() * 40;
                        // è®¾ç½®æ–°çš„éšæœºé€Ÿåº¦
                        train.userData.speed = 0.8 + Math.random() * 0.4;
                        train.userData.lane = randomLane;
                    }
                }
            }
            
            /**
             * æ›´æ–°å»ºç­‘ç‰©ä½ç½®
             * å®ç°å»ºç­‘ç‰©çš„æ— é™å¾ªç¯
             */
            updateBuildings() {
                for (const building of this.buildings) {
                    // ç§»åŠ¨å»ºç­‘ç‰©(æ¯”ç«è½¦ç¨æ…¢)
                    building.position.z += this.PLAYER_SPEED * this.speed * 0.8;
                    
                    // æ£€æŸ¥å»ºç­‘ç‰©æ˜¯å¦è¶…å‡ºè§†é‡
                    if (building.position.z > 50) {
                        // æ‰¾åˆ°æœ€è¿œçš„å»ºç­‘ç‰©Zä½ç½®
                        let farthestZ = -this.GROUND_LENGTH;
                        for (const otherBuilding of this.buildings) {
                            if (otherBuilding !== building && otherBuilding.position.z < farthestZ) {
                                farthestZ = otherBuilding.position.z;
                            }
                        }
                        // å°†å»ºç­‘ç‰©ç§»åŠ¨åˆ°æœ€è¿œä½ç½®åæ–¹
                        building.position.z = farthestZ + 80;
                    }
                }
            }
            
            /**
             * æ›´æ–°é‡‘å¸çŠ¶æ€
             * å¤„ç†é‡‘å¸çš„ç§»åŠ¨ã€æ”¶é›†å’Œé‡ç½®
             */
            updateCoins() {
                for (const coin of this.coins) {
                    // è·³è¿‡å·²æ”¶é›†çš„é‡‘å¸
                    if (!coin.userData.active) continue;
                    
                    // ç§»åŠ¨é‡‘å¸
                    coin.position.z += this.PLAYER_SPEED * this.speed;
                    // æ—‹è½¬é‡‘å¸(è§†è§‰æ•ˆæœ)
                    coin.rotation.z += 0.15;
                    // ä¸Šä¸‹æµ®åŠ¨æ•ˆæœ
                    coin.position.y = 2 + Math.sin(this.clock.getElapsedTime() * 3 + this.coins.indexOf(coin)) * 0.3;
                    
                    // æ£€æŸ¥é‡‘å¸æ”¶é›†
                    if (this.checkCoinCollection(coin)) {
                        this.score += 100; // å¢åŠ åˆ†æ•°
                        coin.userData.active = false; // æ ‡è®°ä¸ºå·²æ”¶é›†
                        coin.visible = false; // éšè—é‡‘å¸
                        this.createCollectEffect(coin.position); // åˆ›å»ºæ”¶é›†ç‰¹æ•ˆ
                    }
                    
                    // é‡ç½®è¶…å‡ºè§†é‡çš„é‡‘å¸
                    if (coin.position.z > 30) {
                        const lane = Math.floor(Math.random() * 3) - 1; // éšæœºè½¨é“
                        coin.position.set(lane * this.LANE_WIDTH, 2, -60 - Math.random() * 40);
                        coin.userData.lane = lane;
                        coin.userData.active = true; // é‡ç½®ä¸ºå¯æ”¶é›†
                        coin.visible = true; // æ˜¾ç¤ºé‡‘å¸
                    }
                }
            }
            
            /**
             * æ£€æŸ¥é‡‘å¸æ”¶é›†
             * ç®€åŒ–ç‰ˆç¢°æ’æ£€æµ‹(è·ç¦»æ£€æµ‹)
             * @param {THREE.Object3D} coin - è¦æ£€æŸ¥çš„é‡‘å¸
             * @return {boolean} æ˜¯å¦æ”¶é›†åˆ°é‡‘å¸
             */
            checkCoinCollection(coin) {
                if (!coin.userData.active) return false;
                // è®¡ç®—ç©å®¶ä¸é‡‘å¸çš„è·ç¦»
                return this.player.position.distanceTo(coin.position) < 2.5;
            }
            
            /**
             * åˆ›å»ºæ”¶é›†ç‰¹æ•ˆ
             * é‡‘å¸æ”¶é›†æ—¶æ˜¾ç¤ºçš„ç²’å­æ•ˆæœ
             * @param {THREE.Vector3} position - ç‰¹æ•ˆä½ç½®
             */
            createCollectEffect(position) {
                const particleCount = 8; // ç²’å­æ•°é‡
                const baseSize = 0.4;    // åŸºç¡€ç²’å­å¤§å°
                
                // =============== åˆ›å»ºç²’å­å‡ ä½•ä½“ ===============
                const geometry = new THREE.BufferGeometry();
                // ç²’å­ä½ç½®æ•°ç»„
                const positions = new Float32Array(particleCount * 3);
                // ç²’å­é¢œè‰²æ•°ç»„
                const colors = new Float32Array(particleCount * 3);
                // ç²’å­å¤§å°æ•°ç»„
                const sizes = new Float32Array(particleCount);
                
                // çº¯é»„è‰²(RGB)
                const pureYellow = [1.0, 0.85, 0.15];
                
                // åˆå§‹åŒ–ç²’å­å±æ€§
                for (let i = 0; i < particleCount; i++) {
                    // éšæœºåŠå¾„å’Œè§’åº¦(åœ†å½¢åˆ†å¸ƒ)
                    const radius = Math.random() * 0.4;
                    const angle = Math.random() * Math.PI * 2;
                    // è®¾ç½®ä½ç½®(å›´ç»•æ”¶é›†ç‚¹åœ†å½¢åˆ†å¸ƒ)
                    positions[i * 3] = position.x + Math.cos(angle) * radius;
                    positions[i * 3 + 1] = position.y + Math.sin(angle) * radius * 1.5;
                    positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.3;
                    
                    // è®¾ç½®é¢œè‰²(å‡ä¸ºé»„è‰²)
                    colors[i * 3] = pureYellow[0];
                    colors[i * 3 + 1] = pureYellow[1];
                    colors[i * 3 + 2] = pureYellow[2];
                    
                    // éšæœºå¤§å°
                    sizes[i] = baseSize * (Math.random() * 0.3 + 0.8);
                }
                
                // è®¾ç½®å‡ ä½•ä½“å±æ€§
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // =============== åˆ›å»ºç²’å­æè´¨ ===============
                const material = new THREE.PointsMaterial({
                    size: baseSize,            // åŸºç¡€å¤§å°
                    vertexColors: true,        // ä½¿ç”¨é¡¶ç‚¹é¢œè‰²
                    transparent: true,         // å¯ç”¨é€æ˜
                    opacity: 1.0,              // åˆå§‹ä¸é€æ˜åº¦
                    sizeAttenuation: true,     // æ ¹æ®è·ç¦»è°ƒæ•´å¤§å°
                    blending: THREE.NormalBlending,
                    alphaTest: 0.1,
                    color: new THREE.Color().setRGB(pureYellow[0], pureYellow[1], pureYellow[2])
                });
                
                // åˆ›å»ºç²’å­ç³»ç»Ÿ
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                
                // =============== ç²’å­åŠ¨ç”» ===============
                // å­˜å‚¨ç²’å­è¿åŠ¨æ–¹å‘å’Œé€Ÿåº¦
                const directions = [];
                const speeds = [];
                
                // åˆå§‹åŒ–ç²’å­è¿åŠ¨å‚æ•°
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    // è®¡ç®—å‘å¤–æ‰©æ•£çš„æ–¹å‘
                    directions.push(new THREE.Vector3(
                        Math.cos(angle) * 0.8,
                        Math.random() * 0.7 + 0.5, // å‘ä¸Šåé‡
                        Math.sin(angle) * 0.8
                    ).normalize());
                    // éšæœºé€Ÿåº¦
                    speeds.push(Math.random() * 0.08 + 0.05);
                }
                
                let lifeTime = 0;          // ç‰¹æ•ˆç”Ÿå‘½å‘¨æœŸ
                const totalLifeTime = 1.2; // ç‰¹æ•ˆæ€»æŒç»­æ—¶é—´
                
                // åŠ¨ç”»å‡½æ•°(é€’å½’è°ƒç”¨å®ç°è¿ç»­åŠ¨ç”»)
                const animate = () => {
                    lifeTime += 0.016; // å›ºå®šæ—¶é—´æ­¥é•¿
                    const progress = lifeTime / totalLifeTime;
                    const positions = particles.geometry.attributes.position.array;
                    const sizes = particles.geometry.attributes.size.array;
                    
                    // æ›´æ–°æ‰€æœ‰ç²’å­
                    for (let i = 0; i < particleCount; i++) {
                        if (progress < 1) {
                            // è®¡ç®—é€Ÿåº¦å› å­(éšæ—¶é—´å‡é€Ÿ)
                            const speedFactor = speeds[i] * Math.pow(1 - progress, 1.8);
                            
                            // æ›´æ–°ç²’å­ä½ç½®
                            positions[i * 3] += directions[i].x * speedFactor;
                            positions[i * 3 + 1] += directions[i].y * speedFactor;
                            positions[i * 3 + 2] += directions[i].z * speedFactor;
                            
                            // ç²’å­å¤§å°åŠ¨ç”»(å…ˆæ”¾å¤§åç¼©å°)
                            if (progress < 0.3) {
                                sizes[i] = baseSize * (1 + progress);
                            } else {
                                sizes[i] = baseSize * (1.3 - (progress - 0.3) * 2);
                            }
                        }
                    }
                    
                    // æ ‡è®°å‡ ä½•ä½“å±æ€§éœ€è¦æ›´æ–°
                    particles.geometry.attributes.position.needsUpdate = true;
                    particles.geometry.attributes.size.needsUpdate = true;
                    // æ·¡å‡ºæ•ˆæœ
                    material.opacity = 1 - Math.pow(progress, 2.5);
                    
                    // ç»§ç»­åŠ¨ç”»æˆ–æ¸…ç†
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ç§»é™¤ç²’å­ç³»ç»Ÿå¹¶é‡Šæ”¾èµ„æº
                        this.scene.remove(particles);
                        particles.geometry.dispose();
                        particles.material.dispose();
                    }
                };
                
                // å¯åŠ¨åŠ¨ç”»
                animate();
            }
            
            /**
             * åŠ¨ç”»å¾ªç¯
             * Three.jsçš„æ ¸å¿ƒæ¸²æŸ“å¾ªç¯
             */
            animate() {
                // é€’å½’è°ƒç”¨å®ç°è¿ç»­åŠ¨ç”»
                requestAnimationFrame(() => this.animate());
                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                this.update();
                // æ¸²æŸ“åœºæ™¯
                this.renderer.render(this.scene, this.camera);
            }
            
            /**
             * å¼€å§‹æ¸¸æˆ
             * éšè—å¼€å§‹ç•Œé¢ï¼Œå¯åŠ¨æ¸¸æˆé€»è¾‘
             */
            startGame() {
                this.gameStarted = true;
                this.gameRunning = true;
                // éšè—å¼€å§‹ç•Œé¢
                document.getElementById("instructions").style.display = "none";
                // æ’­æ”¾è·‘æ­¥åŠ¨ç”»
                if (this.playerActions.run) {
                    this.playerActions.run.play();
                }
            }
            
            /**
             * æ¸¸æˆç»“æŸ
             * æ˜¾ç¤ºç»“æŸç•Œé¢ï¼Œåœæ­¢æ¸¸æˆé€»è¾‘
             */
            gameOver() {
                this.gameRunning = false;
                // åœæ­¢è·‘æ­¥åŠ¨ç”»
                if (this.playerActions.run) {
                    this.playerActions.run.stop();
                }
                // æ˜¾ç¤ºæœ€ç»ˆåˆ†æ•°
                document.getElementById("finalScore").textContent = Math.floor(this.score);
                // æ˜¾ç¤ºç»“æŸç•Œé¢
                document.getElementById("gameOver").style.display = "block";
            }
            
            /**
             * é‡æ–°å¼€å§‹æ¸¸æˆ
             * é‡ç½®æ‰€æœ‰æ¸¸æˆçŠ¶æ€å’Œå¯¹è±¡ä½ç½®
             */
            restartGame() {
                // =============== é‡ç½®æ¸¸æˆçŠ¶æ€ ===============
                this.gameRunning = true;
                this.gameStarted = true;
                this.score = 0;
                this.speed = 1;
                this.playerLane = 0;
                this.isJumping = false;
                this.isSliding = false;
                this.jumpVelocity = 0;
                this.clock.start(); // é‡ç½®åŠ¨ç”»æ—¶é’Ÿ
                
                // =============== é‡ç½®UI ===============
                document.getElementById("gameOver").style.display = "none";
                document.getElementById("instructions").style.display = "none";
                document.getElementById("score").textContent = "0";
                document.getElementById("speed").textContent = "1";
                
                // =============== é‡ç½®ç›¸æœº ===============
                this.camera.position.set(0, 5, 15);
                this.camera.lookAt(0, 1, -10);
                
                // =============== é‡ç½®ç©å®¶ ===============
                this.player.position.set(0,0,0);
                // é‡æ–°å¼€å§‹è·‘æ­¥åŠ¨ç”»
                if (this.playerActions.run) {
                    this.playerActions.run.play();
                }

                // =============== é‡ç½®é‡‘å¸ ===============
                const lanePatterns = [0, 1, -1, 0, 1, -1];
                this.coins.forEach((coin, index) => {
                    const lane = lanePatterns[index % lanePatterns.length];
                    coin.position.set(lane * this.LANE_WIDTH, 2, -20 - index * 5);
                    coin.userData.lane = lane;
                    coin.userData.active = true;
                    coin.visible = true;
                    coin.rotation.set(Math.PI/2, 0, 0);
                });
                
                // =============== é‡ç½®å»ºç­‘ç‰© ===============
                const buildingSpacing = 10;
                this.buildings.forEach((building, index) => {
                    const isLeftSide = index % 2 === 0;
                    const buildingIndex = Math.floor(index / 2);
                    const zPos = -this.GROUND_LENGTH/2 + buildingIndex * buildingSpacing;
                    
                    if (isLeftSide) {
                        building.position.set(-12, -1, zPos);
                    } else {
                        building.position.set(22, -1, zPos);
                    }
                });
                
                // =============== é‡ç½®ç«è½¦ ===============
                const minSpacing = 55;
                const maxSpacing = 80;
                let currentZ = 10;
                
                const trainPatterns = [-1, 0, 1, -1, 0, 1];
                this.trains.forEach((train, index) => {
                    const lane = trainPatterns[index % trainPatterns.length];
                    const spacing = minSpacing + Math.random() * (maxSpacing - minSpacing);
                    
                    train.position.set(lane * this.LANE_WIDTH, 0, currentZ);
                    train.userData.lane = lane;
                    train.userData.speed = 0.8 + Math.random() * 0.4;
                    
                    currentZ -= spacing;
                });
            }
        }
        
        // åˆ›å»ºæ¸¸æˆå®ä¾‹
        const game = new SubwaySurfersGame();
        
        // å°†æ¸¸æˆæ§åˆ¶æ–¹æ³•æš´éœ²ç»™å…¨å±€ä½œç”¨åŸŸ
        window.startGame = () => game.startGame();
        window.restartGame = () => game.restartGame();
        
    </script>
</body>
</html>